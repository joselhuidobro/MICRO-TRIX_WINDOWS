
/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó    
 *  ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïù   
 *     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ïî‚ïù     
 *     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó     
 *     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïó    
 *     ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   
 *‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


TRIX
Programaci√≥n de Redes Empresariales e Industriales | Observabilidad IA 24/7. convergencia IT/OT y Rob√≥tica Avanzada 
El Puente entre la Manufactura Legacy y la Inteligencia Artificial Aut√≥noma.

LA OPORTUNIDAD (EL PROBLEMA)
La industria manufacturera y las PyMEs enfrentan una crisis de desconexi√≥n:
Maquinaria "Ciega": Equipos costosos que funcionan bien mec√°nicamente pero no generan datos (Legacy).
Paros No Planeados: El costo de inactividad es alt√≠simo y el mantenimiento sigue siendo reactivo.
Brecha de Ciberseguridad: Miedo a conectar la planta a la nube por vulnerabilidad a ataques.
Falta de Talento H√≠brido: Escasez de ingenieros que dominen tanto PLCs (OT) como Nube/Docker (IT).

LA SOLUCI√ìN TRIX
TRIX no es solo una consultora; es una arquitectura de software portable y segura (Stack Propio) que moderniza infraestructuras sin reemplazar maquinaria costosa.
Conectividad: Integramos PLCs y sensores (Modbus/ESP32) con Edge Computing (Docker/ROS 2).
Seguridad Grado Militar: T√∫neles cifrados (WireGuard + Cloudflare) que permiten acceso remoto sin exponer la red a internet.
Inteligencia Activa: Pasamos de "ver gr√°ficos" a Agentes de IA Aut√≥nomos que detectan, diagnostican y solucionan problemas sin intervenci√≥n humana.

NUESTROS 4 PILARES DE SERVICIO
1. RETROFIT INDUSTRIAL 4.0
2. REDES EMPRESARIALES SEGURAS
Modernizaci√≥n de maquinaria existente. Instalamos gateways seguros (TRIX-Box) que extraen datos de equipos viejos y los presentan en dashboards modernos (Grafana/UI) en tiempo real. Valor: OEE visible y alertas instant√°neas.
Soluciones "On-Premise" para PyMEs. Configuramos intranets blindadas, VPNs para trabajo remoto seguro y servidores privados. La potencia de la nube con la privacidad de un servidor local.


3. INGENIER√çA & DISE√ëO (CAD/PLM)
4. EDUCACI√ìN DE ALTO NIVEL
Servicios de dise√±o mec√°nico avanzado (CATIA, SolidWorks). Desde la conversi√≥n de planos 2D a modelos 3D manufacturables, hasta la gesti√≥n del ciclo de vida del producto (PLM).
Capacitaci√≥n especializada para equipos de ingenier√≠a corporativos. Cursos √∫nicos en el mercado: "Integraci√≥n de ROS 2 con Docker y Microservicios Industriales".


NUESTRO DIFERENCIADOR: AGENTIC AI (El Futuro Hoy)
A diferencia de la competencia que solo ofrece monitoreo pasivo, TRIX desarrolla IA Ag√©ntica Proactiva:
Supervisi√≥n Aut√≥noma: Agentes que vigilan la infraestructura 24/7.
Auto-Reparaci√≥n: "Si el PLC de la l√≠nea 1 no responde, el agente reinicia el switch industrial y notifica la acci√≥n con evidencia."
Predicci√≥n Real: Correlaci√≥n de variables (temperatura vs. presi√≥n) para predecir fallas mec√°nicas antes de que ocurran.

STACK TECNOL√ìGICO & MODELO DE NEGOCIO
El Stack TRIX (Portable Linux/Windows):
Core: Docker, Kubernetes, ROS 2, micro-ROS.
Conectividad: WireGuard, Cloudflare Tunnel, Caddy (Reverse Proxy), Kong (Gateway).
Data & AI: Prometheus, Grafana, Redis, LangGraph (Orquestaci√≥n de Agentes).
Proyecci√≥n de Crecimiento (2025-2028):
Fase 1 (Servicios & Hardware): Venta de "TRIX-in-a-Box" (Retrofit) y Consultor√≠a CAD.
Fase 2 (SaaS H√≠brido): Suscripci√≥n recurrente por monitoreo remoto y mantenimiento de agentes IA.
Fase 3 (Sovereign AI): Despliegue de modelos de IA privados en nubes soberanas para clientes con alta regulaci√≥n.

CONTACTO Ing. Mecatr√≥nico Senior & Arquitecto de Sistemas L√≠der en la convergencia IT/OT y Rob√≥tica Avanzada [Tu Tel√©fono] | [Tu Email] | [Tu Sitio Web/LinkedIn]

¬øPor qu√© este formato funciona?
Claridad: Separa el "qu√© hacemos" del "c√≥mo lo hacemos".
Valor: Ataca directamente los dolores del cliente (dinero y seguridad).
Futurista pero Real: Vende la IA no como magia, sino como una herramienta de automatizaci√≥n l√≥gica (Agentes).
Versatilidad: Sirve para venderle a un due√±o de f√°brica (Retrofit) o a un Director de Ingenier√≠a (Educaci√≥n/Dise√±o).



 üéØ Executive Summary

TRIX es una plataforma port√°til e integral que transforma la tecnolog√≠a industrial y empresarial mediante la integraci√≥n de redes, automatizaci√≥n, dise√±o mec√°nico e inteligencia artificial aut√≥noma. Nuestra diferenciaci√≥n radica en cerrar el ciclo completo: no solo diagnosticamos problemas, los resolvemos autom√°ticamente y verificamos resultados en tiempo real.

**Propuesta de Valor √önica:** 
- **Productividad 10√ó** mediante automatizaci√≥n de cadenas completas
- **Stack portable** (Windows/Linux) con control de versiones GitLab
- **Agentic AI integrada** con ROS 2 para sistemas OT/IT
- **Cierre de loop completo:** detectar ‚Üí actuar ‚Üí validar

---

## üèóÔ∏è Servicios Core de TRIX

### **Paquete 1: Infraestructura Empresarial**
**Cliente Objetivo:** Pymes y startups que necesitan tecnolog√≠a sin complejidad

**Dolor del Cliente:** "Montar una oficina es complicado, no tengo equipo de sistemas y me preocupa la seguridad."

**Soluci√≥n TRIX:**
- Configuraci√≥n completa de red empresarial (VLANs, firewalls, VPN)
- Servidor propio con Linux + Caddy + Git + Grafana
- Monitoreo 24/7 con respaldos automatizados
- **Stack T√©cnico:** DNS/Proxy/VPN, Postgres, Prometheus, backups automatizados

**Precio:** $5,000 - $15,000 por instalaci√≥n + $500/mes monitoreo

---

### **Paquete 2: Transformaci√≥n Industrial 4.0**
**Cliente Objetivo:** F√°bricas y plantas de manufactura

**Dolor del Cliente:** "Mis m√°quinas no se comunican, pierdo tiempo en reportes manuales y tengo paros inesperados."

**Soluci√≥n TRIX:**
- Integraci√≥n de PLCs, sensores y actuadores en red industrial segura
- Dashboards de OEE (Overall Equipment Effectiveness) en tiempo real
- Separaci√≥n de redes OT/IT con protocolos industriales
- **Stack T√©cnico:** Redes industriales, Clusters PLC, EMQX (MQTT), Node-RED, InfluxDB

**Precio:** $20,000 - $50,000 por l√≠nea de producci√≥n

---

### **Paquete 3: Software Empresarial a Medida**
**Cliente Objetivo:** Empresas medianas con procesos √∫nicos

**Dolor del Cliente:** "Ning√∫n software se adapta a mi proceso. Excel ya no funciona y los ERP grandes son caros."

**Soluci√≥n TRIX:**
- Desarrollo de ERP/PLM custom con metodolog√≠a Agile
- Microservicios y arquitectura escalable
- Control de versiones profesional con GitLab
- **Stack T√©cnico:** Apps custom, microservicios, GitLab, Postgres, Docker

**Precio:** $30,000 - $150,000 por proyecto (6-12 meses)

---

### **Paquete 4: Ingenier√≠a Mec√°nica Avanzada**
**Cliente Objetivo:** Equipos de I+D, startups de hardware

**Dolor del Cliente:** "Necesito dise√±ar un producto f√≠sico profesional con planos para fabricaci√≥n."

**Soluci√≥n TRIX:**
- Modelado 3D con CATIA y SolidWorks
- Documentaci√≥n t√©cnica y planos de conversi√≥n (2D‚Üî3D)
- An√°lisis de ensambles y optimizaci√≥n para manufactura
- **Servicios:** Dise√±o conceptual, modelado param√©trico, planos t√©cnicos

**Precio:** $80 - $150/hora o $10,000 - $40,000 por proyecto

---

## ü§ñ Innovaci√≥n: Agentic AI + ROS 2

### **¬øPor Qu√© Importa?**
- **Productividad 10√ó:** Automatiza cadenas completas (logs ‚Üí diagn√≥stico ‚Üí ticket ‚Üí fix ‚Üí validaci√≥n)
- **Orquestaci√≥n multi-herramienta:** GitLab, Prometheus, Kong, Redis, EMQX sin esfuerzo manual
- **Cierre de loop:** No recomienda, ejecuta y verifica hasta cumplir objetivos
- **Contexto y memoria:** Recuerda decisiones, estados del sistema y pol√≠ticas
- **Tiempo real:** Reacciona en segundos a eventos y m√©tricas

### **Casos de Uso Concretos**

| **Dominio** | **Problema** | **Soluci√≥n Agentic AI TRIX** |
|-------------|--------------|------------------------------|
| **DevOps/Plataforma** | GitLab falla (404/502) | Agent vigila m√©tricas, crea MR, edita prometheus.yml, lanza reconfigure, valida y cierra issue |
| **Rob√≥tica/OT** | Caudal bajo o temperatura alta | Agentes coordinan ESP32+micro-ROS, ajustan setpoints, programan mantenimiento, notifican HMI |
| **ERP/Operaci√≥n** | Priorizaci√≥n de √≥rdenes | Agent prioriza por margen/SLAs, genera cotizaciones, agenda t√©cnicos, verifica inventario |
| **Ciberseguridad** | Anomal√≠as en Wireguard/Knot | Aplica playbooks autom√°ticos, m√≠nima intervenci√≥n humana, registra todo para auditor√≠a |

---

## üèõÔ∏è Arquitectura M√≠nima del Agente

```mermaid
graph TD
    A[Eventos: Prometheus/EMQX/Kong] --&gt; B[Cola: Redis/Node-RED]
    B --&gt; C[Agente: Monitor/Executor/Validator]
    C --&gt; D[Herramientas: CLI/HTTP/GitLab API/ROS 2]
    C --&gt; E[Memoria: Vector DB + Estado Operativo]
    C --&gt; F[Pol√≠ticas: YAML con SLOs y L√≠mites]
    C --&gt; G[GitOps: MR con Tests Autom√°ticos]
    G --&gt; H[Validaci√≥n y Rollback Autom√°tico]


Arquitectura (resumen express)


‚úÖ ‚ÄúGitLab corriendo en mi red privada, accesible solo por VPN cuando estoy fuera‚Äù ‚Üí eso s√≠ es pro.

Caddy (edge p√∫blico)
√önico servicio expuesto a Internet (80/443). Termina TLS/HTTP3 y hace reverse proxy hacia tu Nginx interno. Tambi√©n puede rutear /api a Kong.
Beneficio: seguridad (solo un puerto de entrada), certificados autom√°ticos y enrutamiento limpio.

Nginx ‚Äútrixweb‚Äù (origin est√°tico)
Sirve tu sitio TRIX ya renderizado (carpeta public/). No expone puertos al host; solo es accesible por Caddy dentro de la red Docker.
Beneficio: desacopla edge de contenido, simple y r√°pido.

Hugo builder
Contenedor que compila el repo Hugo ‚Üí genera HTML/CSS/JS en public/ (volumen). Lo ejecutas bajo demanda (o por CI/CD).
Beneficio: despliegue reproducible; no metes toolchain en el servidor web.

Kong (API Gateway, interno)
Recibe tr√°fico /api desde Caddy y lo distribuye a servicios internos (Flask, Spring Boot, etc.).
Beneficio: plugins (auth, rate-limit, logs), versi√≥n √∫nica para todas las APIs.

VPN (WireGuard)
Acceso administrativo/privado a toda la malla (p. ej. 10.6.0.0/24). Los peers entran por WG y ven los servicios internos sin exponerlos a Internet.
Beneficio: operaci√≥n segura y troubleshooting ‚Äúcomo si estuvieras en LAN‚Äù.

Redes Docker

web-net: Caddy ‚Üî (opcional) builder; superficie p√∫blica m√≠nima.

trix-net: Nginx, Kong y microservicios (UI Flask, Spring, Redis, EMQX, etc.).
Beneficio: segmentaci√≥n: lo p√∫blico separado de lo interno.

(Opcional) Knot DNS
Autoritativo para tu dominio o interno para la VPN. Si es p√∫blico: abre 53/TCP+UDP y delega NS/glue; si es interno: resuelve nombres de tu malla.



# TRIX Stack ‚Äî Radar UI, ROS¬†2/micro‚ÄëROS, Modbus, Observabilidad y VPN (WireGuard)

> **Resumen**: Este README describe c√≥mo visualizar **equipos en la LAN (192.168.x.x)** y **servicios en Docker/trix‚Äënet (172.18.x.x)** en una sola UI (‚Äú**Radar**‚Äù), c√≥mo verificar el flujo **ROS¬†2 ‚Üí micro‚ÄëROS ‚Üí ESP32**, c√≥mo **enviar Modbus solo al HMI** con IP por variables de entorno (sin hardcode), y c√≥mo operar la capa de **observabilidad** (Prometheus/Grafana/Redis/Node‚ÄëRED) y la **VPN WireGuard**. Incluye comandos de operaci√≥n, diagn√≥stico y limpieza.

> **Nota**: Se antepone `sudo` a los comandos de Docker/administraci√≥n. Para llamadas HTTP con `curl`, **no es necesario** `sudo` en la mayor√≠a de los casos.

---

## √çndice

1. [Arquitectura y objetivos](#arquitectura-y-objetivos)
2. [Accesos r√°pidos (localhost)](#accesos-r√°pidos-localhost)
3. [Modelo de red (fusi√≥n 172.18.x.x + 192.168.x.x)](#modelo-de-red-fusi√≥n-17218xx--192168xx)
4. [UI ‚ÄúRadar‚Äù: endpoints y modos](#ui-radar-endpoints-y-modos)
5. [ROS¬†2 ‚Üí micro‚ÄëROS ‚Üí ESP32 (verificaci√≥n)](#ros-2--micro-ros--esp32-verificaci√≥n)
6. [Modbus (solo HMI, IP por variables de entorno)](#modbus-solo-hmi-ip-por-variables-de-entorno)
7. [Observabilidad (Prometheus/Grafana/Redis/Node‚ÄëRED)](#observabilidad-prometheusgrafanaredisnode-red)
8. [Redis: claves y salud](#redis-claves-y-salud)
9. [WireGuard: estado, peers y configuraci√≥n de cliente](#wireguard-estado-peers-y-configuraci√≥n-de-cliente)
10. [ESP32 con ESP‚ÄëIDF: build/flash/monitor](#esp32-con-esp-idf-buildflashmonitor)
11. [Limpieza de Docker (‚ö†Ô∏è con cuidado)](#limpieza-de-docker--con-cuidado)
12. [Operaci√≥n y logs frecuentes](#operaci√≥n-y-logs-frecuentes)
13. [Seguridad y buenas pr√°cticas](#seguridad-y-buenas-pr√°cticas)
14. [Snippets √∫tiles (cURL y Prometheus)](#snippets-√∫tiles-curl-y-prometheus)

---






## Arquitectura y objetivos

```text
Cliente (LAN/VPN) ‚îÄ‚îÄ‚ñ∂  Kong (30080) ‚îÄ‚îÄ‚ñ∂  UI/Flask, Grafana, Prometheus, Node‚ÄëRED
         ‚îÇ                 ‚îÇ
         ‚îÇ                 ‚îú‚îÄ‚îÄ‚ñ∂  UI ‚ÄúRadar‚Äù (funde 192.168.x.x + 172.18.x.x con etiquetas)
         ‚îÇ                 ‚îî‚îÄ‚îÄ‚ñ∂  Endpoints de telemetr√≠a, ROS y salud

ROS¬†2 (Flask) ‚îÄ‚îÄ‚ñ∂ micro‚ÄëROS Agent (UDP) ‚îÄ‚îÄ‚ñ∂ ESP32 (micro‚ÄëROS)





# Vector 1: Datos de Robot (micro-ROS)
robot_encoder ‚Üí /dev/ttyUSB0 ‚Üí UDP ‚Üí micro-ROS Agent

# Vector 2: Datos de Red Industrial  
net_sensor_cdmx ‚Üí ARP/UDP ‚Üí Redis ‚Üí REDIS_KEY_DEVICES=trix:udp:devices:last

# Vector 3: Estado Sistema (infraestructura)
Redis (estado) + Host network (acceso total) ‚Üí Posible acci√≥n


Trazabilidad completa: OpenTelemetry (OTel) ‚Üí Prometheus/Grafana + Jaeger/Tempo.

Memoria de agentes y persistencia: LangGraph persistence + vector DB (pgvector/Qdrant).

Ejecuci√≥n de modelos desacoplada: vLLM/TGI como ‚Äúmodel server‚Äù detr√°s de tu agente.

Evaluaci√≥n continua: LangSmith/Ragas + tests de regresi√≥n de prompts/policies.

Cola/event bus productivo: Redis Streams est√° bien; NATS/Kafka si escalas.

Secretos & supply-chain: Vault/SOPS + SBOM (Syft/Grype) en tus im√°genes.

Despliegue: pasar de Compose a k3s/Kubernetes cuando tengas 3+ nodos.

RBAC y pol√≠ticas de datos m√°s finas: OPA + Rego con tests y CI.

API Gateway con rate-limits/circuit-breakers (Kong ya lo tienes: config√∫ralo para AI).


Modbus: Flask/HMI (IP por env vars)  ‚úñ  (no enviar al ESP32)
```

**Objetivos clave**
- Visualizar **LAN** y **trix‚Äënet** en una sola p√°gina con etiqueta de **origen**.
- Asegurar que la **UI/Flask publica en ROS¬†2** y llega al **micro‚ÄëROS Agent** (UDP ok).
- **Modbus** limitado al **HMI**, con IP configurable por **variables de entorno**.
- Exponer endpoints de **observabilidad** y comandos de **operaci√≥n/diagn√≥stico**.

---


‚úÖ Redes separadas: web-net para servicios p√∫blicos, trix-net para internos
‚úÖ Vol√∫menes persistentes: Definidos centralmente en 00-foundation
‚úÖ Token seguro: Almacenado en .env, no en el c√≥digo
‚úÖ Healthcheck: El tunnel espera a que Caddy est√© listo
‚úÖ Sin puertos expuestos p√∫blicamente: Todo va por Cloudflare Tunnel


cloudflare_tunnel:
  command: tunnel --url http://caddy:80  # ‚Üê SOLO este endpoint
```

‚úÖ **Accesible**: Tu sitio Hugo servido por Caddy en el puerto 80
- `https://random-xyz.trycloudflare.com/` ‚Üí Hugo
- `https://random-xyz.trycloudflare.com/docs` ‚Üí Sphinx docs
- `https://random-xyz.trycloudflare.com/api` ‚Üí Doxygen API

## Lo que NO es accesible:

‚ùå Kong (puerto 30080, 8100)
‚ùå Knot DNS (puerto 5353)
‚ùå Cualquier otro servicio en `trix-net`
‚ùå Tu equipo local
‚ùå Otros contenedores Docker
‚ùå Bases de datos (PostgreSQL, Redis)
‚ùå EMQX, Node-RED, Grafana, etc.

## ¬øPor qu√© es seguro?
```
Internet
    ‚Üì
Cloudflare Tunnel (tunnel container)
    ‚Üì
[web-net] ‚Üê Solo esta red Docker
    ‚Üì
Caddy:80 ‚Üê SOLO este servicio
    ‚Üì
Vol√∫menes de archivos est√°ticos (hugo_public, sphinx_html, doxygen_html)
```

**Aislamiento por capas:**

1. **Red `trix-net`**: Completamente aislada, el tunnel ni siquiera est√° conectado
2. **Red `web-net`**: El tunnel solo puede hablar con Caddy
3. **Caddy**: Solo sirve archivos est√°ticos desde vol√∫menes read-only (`:ro`)

## Ejemplo visual de tu arquitectura:
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Internet (p√∫blico)                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ Cloudflare     ‚îÇ
          ‚îÇ Tunnel         ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ      web-net (aislada)    ‚îÇ
    ‚îÇ                           ‚îÇ
    ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
    ‚îÇ    ‚îÇ   Caddy:80  ‚îÇ        ‚îÇ
    ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
    ‚îÇ           ‚îÇ               ‚îÇ
    ‚îÇ    Archivos est√°ticos     ‚îÇ
    ‚îÇ    (solo lectura)         ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ   trix-net (privada)      ‚îÇ
    ‚îÇ                           ‚îÇ
    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
    ‚îÇ  ‚îÇ Kong ‚îÇ  ‚îÇ Knot ‚îÇ      ‚îÇ
    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
    ‚îÇ                           ‚îÇ
    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
    ‚îÇ  ‚îÇ EMQX ‚îÇ  ‚îÇ  DB  ‚îÇ      ‚îÇ
    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üë
         ‚îî‚îÄ‚îÄ SIN acceso desde Internet


## Accesos r√°pidos (localhost)

> Si entras por **VPN WireGuard**, reemplaza `localhost:30080` por **`10.6.0.1:30080`**.

- **UI**: `http://localhost:30080/ui`
- **Index (fallback)**: `http://localhost:30080/`
- **Telemetr√≠a (UI)**: `http://localhost:30080/telemetry` ¬∑ `http://localhost:30080/ui/telemetry` ¬∑ `http://localhost:30080/setpoint`
- **UDP devices**: `http://localhost:30080/udp/devices` (SSE: `/udp/devices/stream`)
- **ROS (t√≥picos UI)**: `http://localhost:30080/ui/ros/topics`
- **Node‚ÄëRED**: `http://localhost:30080/nodered`
- **Grafana**: `http://localhost:30080/grafana`
- **Prometheus (targets/metrics)**: `http://localhost:9090/targets?search=` ¬∑ `http://localhost:9090/metrics`
- **Redis exporter**: `http://localhost:9121/metrics`
- **Git observer**: `http://localhost:7011/metrics`
- **Otro exporter** (ajusta): `http://localhost:8100/metrics`

---

## Modelo de red (fusi√≥n 172.18.x.x + 192.168.x.x)

- **LAN**: `192.168.x.x` (host y dispositivos f√≠sicos, p. ej. ESP32)
- **Bridge trix‚Äënet (Docker)**: `172.18.x.x` (servicios en contenedores)
- La UI ‚ÄúRadar‚Äù realiza un **merge** etiquetando `source: lan | radar | trix`.

---

## UI ‚ÄúRadar‚Äù: endpoints y modos

**Mezcla (LAN + 172.18)**
- JSON principal: `http://localhost:5000/udp/devices` y `http://localhost:30080/udp/devices`
- Snapshot con breakdown: `http://localhost:5000/udp/devices/snapshot`

**Modos de depuraci√≥n**
- Solo **LAN**: `http://localhost:5000/udp/devices/debug?mode=lan`
- Solo **bridge 172.18** (radar): `http://localhost:5000/udp/devices/debug?mode=radar`
- Solo **contenedores** (Docker SDK): `http://localhost:5000/udp/devices/debug?mode=trix`

**Streams SSE**
- Dispositivos: `http://localhost:30080/udp/devices/stream`
- Orientaci√≥n: `http://localhost:30080/orientation`

> **Tip**: Si un host no aparece, prueba conectividad (ping/ARP), revisa permisos del esc√°ner y que el servicio publicador est√© corriendo.

---

## ROS 2 ‚Üí micro‚ÄëROS ‚Üí ESP32 (verificaci√≥n)

```bash
sudo docker exec -it flask_ui_encoder_robot bash -lc 'source /opt/ros/$ROS_DISTRO/setup.bash && ros2 topic list'
sudo docker exec -it flask_ui_encoder_robot bash -lc 'source /opt/ros/$ROS_DISTRO/setup.bash && ros2 topic info -v /servo_setpoint_deg'
sudo docker exec -it flask_ui_encoder_robot bash -lc 'source /opt/ros/$ROS_DISTRO/setup.bash && ros2 topic info -v /RELAY_telemetry_11B384'
sudo docker exec -it flask_ui_encoder_robot bash -lc 'source /opt/ros/$ROS_DISTRO/setup.bash && ros2 topic info -v /relevadores'
sudo docker exec -it flask_ui_encoder_robot bash -lc 'source /opt/ros/$ROS_DISTRO/setup.bash && ros2 topic info -v /rosout'

# Gr√°fico de nodos
sudo docker exec -it flask_ui_encoder_robot bash -lc 'source /opt/ros/$ROS_DISTRO/setup.bash; rqt_graph'
```

> **Nota**: Si `ros2` no se encuentra, confirma `which ros2` y que se haya `source`‚Äëado el `setup.bash`.

---

## Modbus (solo HMI, IP por variables de entorno)

- Enviar **Modbus √∫nicamente al HMI**. Evitar enviar Modbus al ESP32.
- IP/puerto del HMI por **variables de entorno** (ej.: `MODBUS_HMI_IP`, `MODBUS_HMI_PORT`).
- Endpoints UI relacionados: `http://localhost:30080/data` (datos) y `http://localhost:30080/setpoint`.

> **Motivo**: Separaci√≥n de responsabilidades, menor superficie de ataque y flexibilidad de despliegue.

---

## Observabilidad (Prometheus/Grafana/Redis/Node‚ÄëRED)

**Checks r√°pidos**
```bash
# Node‚ÄëRED v√≠a Kong
curl -I http://localhost:30080/nodered

# ¬øGrafana up en Prometheus?
curl -G 'http://localhost:9090/api/v1/query' --data-urlencode 'query=up{job="grafana"}'
curl -G 'http://localhost:9090/api/v1/query' --data-urlencode 'query=sum by (job) (up)'
```

**Dashboards/Targets**
- Grafana: `http://localhost:30080/grafana`
- Prometheus targets: `http://localhost:9090/targets?search=`

> **Tip**: A√±ade `wireguard`, `ui`, `nodered`, `redis_exporter`, etc. como **jobs** para tener una vista por servicio (`sum by (job) (up)`).

---

## Redis: claves y salud

```bash
sudo docker exec -it redis_trix redis-cli -a trixredis123 GET trix:udp:devices:last
sudo docker exec -it redis_trix redis-cli -a trixredis123 INFO persistence
sudo docker exec -it redis_trix redis-cli -a trixredis123 INFO stats
```

- Salud en UI: `http://localhost:30080/redis/health`
- La clave `trix:udp:devices:last` debe devolver un JSON/DICT con `devices > 0`.

---

## WireGuard: estado, peers y configuraci√≥n de cliente

**Inspecci√≥n y logs**
```bash
sudo docker ps --format "{{.Names}}  {{.Ports}}" | grep wireguard
sudo docker inspect wireguard | grep -A4 '"Ports"'
sudo docker logs wireguard | tail -n 80
```

**Estado de interfaz/handshakes**
```bash
sudo docker exec -it wireguard bash -lc 'wg show; wg show wg0 latest-handshakes'
sudo docker exec -it wireguard bash -lc 'ip addr show wg0; wg show'
sudo docker exec -it wireguard bash -lc 'ls -R /config'
sudo docker exec -it wireguard bash -lc 'ping -c 3 10.6.0.2'
```
VPN
http://10.6.0.1:30080/ui
http://10.6.0.1:9090/targets?search=`
http://10.6.0.1/:30080/redis/health
http://10.6.0.1:30080/nodered
http://10.6.0.1:8080/
http://10.6.0.1:30080/grafana

http://10.6.0.1:6800/login/


http://10.6.0.1:3000/grafana/metrics
http://10.6.0.1:9090/metrics


docker exec -it knot knotc conf-check
docker exec -it knot kzonecheck /zones/example.test.zone

 sudo docker exec -it kong_db_less getent hosts trix-erp

docker logs -f postgres_trix | sed -n '1,120p'

sudo docker logs cloudflare_tunnel | grep -Eo 'https://[a-z0-9.-]*trycloudflare.com' | head -1


# y prueba siguiendo el redirect:



sudo ansible-playbook -i hosts.ini site.yml --syntax-check

wg genkey | tee server_private.key | wg pubkey > server_public.key
# Crear/reescribir vault.yml con la clave privada WG
sudo bash -c 'printf -- "---\nwg_private_key: \"%s\"\n" "$(tr -d "\n" < server_private.key)" > vault.yml'

# Verifica el contenido (debe verse YAML con una sola l√≠nea de clave)
cat vault.yml


hostname -I
ip -4 addr | grep -A2 -E 'state UP|inet '

sudo wg show
curl -4 ifconfig.me      # en el CEL con la VPN activa debe ver la IP p√∫blica del servidor
# en el servidor:
sudo iptables -t nat -S | grep MASQUERADE
sudo iptables -S FORWARD | grep -E 'wg0|RELATED,ESTABLISHED'
sudo tcpdump -ni eth0 udp port 51820 


sudo # Ver qu√© config est√° usando
docker exec -it kiali sh -c 'echo $CONFIG_FILE && sed -n "1,60p" $CONFIG_FILE'

# Ver env efectivas
docker inspect kiali --format '{{range .Config.Env}}{{println .}}{{end}}' | egrep 'CONFIG_FILE|AUTH_STRATEGY|LOGIN_TOKEN'

cd ~/Documents/micro-trix_2/deploy
sudo ansible-playbook -i hosts.ini site.yml -l jetson --ask-vault-pass



 sudo systemctl status wg-quick@wg0 --no-pager


 curl -4 ifconfig.me ; echo
201.141.100.234
ip -4 addr show eth0 | grep inet
    inet 192.168.0.82/24 brd 192.168.0.255 scope global dynamic noprefixroute eth0



**Ver mounts/env de wireguard**
```bash
sudo docker inspect -f '{{range .Config.Env}}{{println .}}{{end}}' wireguard | grep WG_QUICK_USERSPACE || echo "NO_ESTA"
sudo docker inspect wireguard --format '{{range .Mounts}}{{println .Type " " .Source " -> " .Destination}}{{end}}'
```

**Sanitizar y mostrar `wg0.conf`**
```bash
sed -n '1,200p' ./wireguard/wireguard_config/wg0.conf \
 | sed 's/PrivateKey.*/PrivateKey=<hidden>/' \
 | sed 's/PublicKey.*/PublicKey=<hidden>/'
```

**Generar QR local (ej. `peer1.conf`)**
```bash
qrencode -t ansiutf8 < peer1.conf
```

**Plantilla: configuraci√≥n de celular (WireGuard App)**

**Interface**
- **Name**: `ui2` (o el que prefieras)
- **Private key**: generada por la app
- **Address**: `10.6.0.2/32`
- **DNS**: `1.1.1.1`
- **MTU**: `1420`

**Peer**
- **Public key**: *del servidor (en `wg0.conf`)*
- **AllowedIPs**: `10.6.0.0/24,192.168.0.0/24`
- **Endpoint**: `X.X.X.X:51820` *(IP/host p√∫blico real + puerto)

**Ruta v√≠a VPN**
```
Cliente (cel/PC) ‚Üí 10.6.0.1:30080 (host wg0) ‚Üí Kong ‚Üí ui:5000, grafana:3000, prometheus:9090, ...
```

> **Tip**: Usa `wg show wg0 latest-handshakes` para ver si hubo intercambio reciente (epoch seconds por peer).

---

## ESP32 con ESP‚ÄëIDF: build/flash/monitor

```bash
# Build limpio
sudo docker exec -it ros_relevadores_y_encoder bash -lc '
  if [ -f /opt/esp/idf/export.sh ]; then source /opt/esp/idf/export.sh;
  elif [ -f /opt/esp-idf/export.sh ]; then source /opt/esp-idf/export.sh; fi;
  cd /esp2024 && idf.py fullclean && idf.py build'

# Flash
a
sudo docker exec -it ros_relevadores_y_encoder bash -lc '
  if [ -f /opt/esp/idf/export.sh ]; then source /opt/esp/idf/export.sh;
  elif [ -f /opt/esp-idf/export.sh ]; then source /opt/esp-idf/export.sh; fi;
  cd /esp2024 && idf.py -p /dev/ttyUSB0 flash'

# Monitor
sudo docker exec -it ros_relevadores_y_encoder bash -lc '
  if [ -f /opt/esp/idf/export.sh ]; then source /opt/esp/idf/export.sh;
  elif [ -f /opt/esp-idf/export.sh ]; then source /opt/esp-idf/export.sh; fi;
  cd /esp2024 && idf.py -p /dev/ttyUSB0 monitor'

# Comprobar dispositivo y permisos dentro del contenedor
sudo docker exec -it ros_relevadores_y_encoder bash -lc 'ls -l /dev/ttyUSB0; id; groups'
```

> **Nota**: Aseg√∫rate de mapear `/dev/ttyUSB0` al contenedor (y grupos `dialout`/`uucp` seg√∫n distro).

---

## Limpieza de Docker (‚ö†Ô∏è con cuidado)

```bash
# Parar todo
a
sudo docker stop $(sudo docker ps -aq)

# Borrar contenedores y vol√∫menes (no en uso)
sudo docker rm -f $(sudo docker ps -aq) 2>/dev/null
sudo docker volume rm $(sudo docker volume ls -q) 2>/dev/null

# Prune (im√°genes, cach√©s y vol√∫menes no usados)
sudo docker system prune -af
sudo docker system prune -a --volumes
```

> **Advertencia**: Esto elimina **recursos no usados** globalmente. Revisa si hay vol√∫menes/im√°genes que debas conservar.

---

## Operaci√≥n y logs frecuentes

```bash
# Logs
sudo docker logs git_observer
sudo docker logs -f net_sensor_cdmx
sudo docker logs -n 50 net_sensor_cdmx
sudo docker logs -f micro_ros_agent_HMI2
sudo docker logs flask_ui_encoder_robot
sudo docker logs wireguard | tail -n 80

# Entrar a contenedores
sudo docker exec -it wireguard bash
sudo docker exec -it flask_ui_encoder_robot bash
sudo docker exec -it flask_ui_encoder_robot bash -lc "source /opt/ros/\$ROS_DISTRO/setup.bash"
```

---

## Seguridad y buenas pr√°cticas

- **Modbus**: limitar al HMI; si expones fuera, usa **listas de control**/firewall y segmentaci√≥n.
- **Redis**: si se accede m√°s all√° de `localhost/VPN`, usa **ACL**/contrase√±as fuertes y `bind` estricto.
- **WireGuard**: fija puerto (p.ej. `51820/UDP`), monitorea **handshakes** y rota claves cuando proceda.
- **Kong**: protege rutas con **auth**/rate‚Äëlimit si expones a internet; usa certificados v√°lidos.

---

## Snippets √∫tiles (cURL y Prometheus)

```bash
# Node‚ÄëRED (v√≠a Kong)
curl -I http://localhost:30080/nodered

# Prometheus: estado de Grafana
curl -G 'http://localhost:9090/api/v1/query' --data-urlencode 'query=up{job="grafana"}'

# Prometheus: up por job
curl -G 'http://localhost:9090/api/v1/query' --data-urlencode 'query=sum by (job) (up)'

# Clave Redis desde Flask (debug)
curl http://localhost:5000/debug/redis-key

# Radar: modos
a
curl "http://localhost:5000/udp/devices/debug?mode=lan"
curl "http://localhost:5000/udp/devices/debug?mode=radar"
curl "http://localhost:5000/udp/devices/debug?mode=trix"

# JSON mezclado y snapshot
a
curl "http://localhost:5000/udp/devices"
curl "http://localhost:5000/udp/devices/snapshot"
```

---

### Ap√©ndice: utilidades WireGuard

```bash
# Mostrar wg0 y √∫ltimas negociaciones
a
sudo docker exec -it wireguard bash -lc 'wg show; wg show wg0 latest-handshakes'

# Revisar puertos/mounts de wireguard
a
sudo docker ps --format "{{.Names}}  {{.Ports}}" | grep wireguard
sudo docker inspect wireguard | grep -A4 '"Ports"'
sudo docker inspect wireguard --format '{{range .Mounts}}{{println .Type " " .Source " -> " .Destination}}{{end}}'

# Generar QR a partir de peer1.conf (en host)
qrencode -t ansiutf8 < peer1.conf
```

---

**Mantenimiento**: si deseas, podemos a√±adir una tabla de **estado** (jobs up/down), badges, y un peque√±o **diagrama** en Mermaid para la topolog√≠a.


# Replicaci√≥n del stack DRON UI + micro-ROS Agent (Minikube)

2025master-DRONespui/
‚îú‚îÄ 2025_DOCKER-dronui/
‚îÇ  ‚îú‚îÄ Dockerfile
‚îÇ  ‚îî‚îÄ app/...
‚îú‚îÄ k8s/
‚îÇ  ‚îú‚îÄ base/
‚îÇ  ‚îÇ  ‚îú‚îÄ kustomization.yaml
‚îÇ  ‚îÇ  ‚îú‚îÄ app_ui/
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ deployment.yaml
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ service.yaml
‚îÇ  ‚îÇ  ‚îî‚îÄ micro-ros-agent/
‚îÇ  ‚îÇ     ‚îú‚îÄ deployment.yaml
‚îÇ  ‚îÇ     ‚îî‚îÄ service.yaml
‚îÇ  ‚îî‚îÄ overlays/
‚îÇ     ‚îî‚îÄ minikube/
‚îÇ        ‚îú‚îÄ kustomization.yaml
‚îÇ        ‚îú‚îÄ patch-app-ui-cmd.yaml
‚îÇ        ‚îî‚îÄ patch-app-ui-imagepolicy.yaml
‚îú‚îÄ scripts/
‚îÇ  ‚îú‚îÄ dev_up.sh
‚îÇ  ‚îú‚îÄ dev_down.sh
‚îÇ  ‚îî‚îÄ dev_logs.sh
‚îî‚îÄ README_replicacion.md


## Prerrequisitos
- Docker, kubectl, minikube, kustomize (kubectl >=1.14 ya trae `-k`)
- Recursos del proyecto:
  - `2025_DOCKER-dronui/Dockerfile`
  - `2025_DOCKER-dronui/app/...`
  - `k8s/` (esta carpeta)

## Levantar (DEV Minikube)
```bash
scripts/dev_up.sh
# abre la UI:
# http://$(minikube ip):30500/



sudo docker system prune -a
docker system prune -a --volumes
sudo docker-compose build
docker exec -it robot bash

source /opt/esp-idf/export.sh


oermitir a docker abrir gzebo


echo $DISPLAY || true
export DISPLAY=${DISPLAY:-:0}
xhost +SI:localuser:root   # si no jala, usa: xhost +local:root
----------------------------------------


kubectl -n trix get deploy
kubectl -n trix rollout status deploy/ui
kubectl -n trix rollout status deploy/micro-ros-agent
kubectl -n trix rollout status deploy/springboot-api

...

# Entorno m√≠nimo para esta shell
source /opt/ros/$ROS_DISTRO/setup.bash
source /usr/share/gazebo/setup.sh
export ROS_DOMAIN_ID=88
export GAZEBO_MASTER_URI=http://127.0.0.1:11347

# Relanza
/usr/local/bin/gz_up.sh

# Verifica que YA est√°n los servicios
ros2 service list | grep -E 'spawn_entity|delete_entity|set_entity_state|get_entity_state'
------

crear y entrar al pod y container 

kubectl -n trix run ui-debug --image=trix/ui:dev --restart=Never --command -- sh -lc '
  echo "CWD=$(pwd)"; echo; 
  ls -R /app | sed -n "1,200p"; 
  python - <<PY
import os
print("\\nPY files under /app:")
for r,_,f in os.walk("/app"):
  for x in f:
    if x.endswith(".py"):
      print(os.path.join(r,x))
PY
  sleep 3600
'


kubectl -n trix exec -it ui-debug -- sh
# (cuando termines: kubectl -n trix delete pod ui-debug --force --grace-period=0)

---------------------------------------------
kubectl create ns trix 2>/dev/null || true
kubectl config set-context --current --namespace=trix


kubectl apply -f .
kubectl get pods -w
kubectl get deploy
kubectl rollout status deploy/<NOMBRE_DEL_DEPLOY>

----
1) Borra por lotes, sin esperar, y en paralelo
Esto evita que kubectl se ‚Äúahogue‚Äù intentando borrar todo a la vez.
# A) Workloads primero (sin esperar)
for k in deploy sts ds job cronjob rs pod; do
  kubectl delete "$k" --all --wait=false || true
done

# B) Servicios y red
for k in svc ing networkpolicy; do
  kubectl delete "$k" --all --wait=false --ignore-not-found || true
done

# C) Config/secrets y storage
kubectl delete cm,secret --all --wait=false || true
kubectl delete pvc --all --wait=false --ignore-not-found || true

---------------
kubectl get pods -l app=ui


POD=$(kubectl get pods -l app=ui -o jsonpath='{.items[0].metadata.name}')
kubectl logs $POD --tail=200
kubectl logs $POD --previous --tail=200 || true
--------------------
 ros2 run xacro xacro /sim/models/robotio/robotio.urdf.xacro   mesh_root:=/sim/models/robotio   -o /tmp/robotio.urdf
ros2 run gazebo_ros spawn_entity.py   -entity robotio   -file /tmp/robotio.urdf   -x 0 -y 0 -z 0.2

ros2 service list | grep -E 'spawn_entity|delete_entity|set_entity_state|get_entity_state'



# Apuntar al nuevo tag
kubectl set image deploy/ui ui=joselhuidobro/flask_ui_robot:v4

# Evitar pulls remotos (usa la imagen local de Minikube)
kubectl patch deploy ui -p '{"spec":{"template":{"spec":{"containers":[{"name":"ui","imagePullPolicy":"IfNotPresent"}]}}}}'

# Borra el Pod que estaba en ImagePullBackOff para reintentar
kubectl delete pod -l app=ui

# Ver el rollout
kubectl rollout status deploy/ui



kubectl port-forward svc/ui 8080:5500
# Abre http://localhost:8080


URDF=/tmp/robotio.urdf

# (Re)genera URDF si hace falta
test -f "$URDF" || ros2 run xacro xacro /sim/models/robotio/robotio.urdf.xacro \
  mesh_root:=/sim/models/robotio -o "$URDF"

# Levanta RSP en segundo plano (necesario para que el plugin arranque)
{
  echo "robot_state_publisher:"
  echo "  ros__parameters:"
  echo "    use_sim_time: true"
  echo "    robot_description: |"
  sed 's/^/      /' "$URDF"
} > /tmp/rsp.yaml

( ros2 run robot_state_publisher robot_state_publisher \
    --ros-args --params-file /tmp/rsp.yaml >/tmp/rsp.log 2>&1 ) &

# Respawnea el modelo (por si ya estaba); ignora error si no existe
ros2 service call /delete_entity gazebo_msgs/srv/DeleteEntity "{name: 'robotio'}" || true
ros2 run gazebo_ros spawn_entity.py -entity robotio -file "$URDF" -x 10 -y 0 -z 0.20

--------------------------------

kubectl exec -it "$POD" -- bash -lc '
> echo "ROS_DISTRO=$ROS_DISTRO"
> source /opt/ros/$ROS_DISTRO/setup.bash || { echo "no se pudo sourcear ROS"; exit 1; }
> python3 - <<PY
> import sys
> print("python:", sys.version)
> try:
>     import rclpy
>     print("rclpy OK")
> except Exception as e:
>     print("rclpy FAIL:", e)
>     import pprint; pprint.pp(sys.path)
>     raise
> PY
> '
ROS_DISTRO=humble
python: 3.10.12 (main, May 27 2025, 17:12:29) [GCC 11.4.0]
rclpy OK
jose@jose-K45VD:~/Descargas/2025_robo



 kubectl exec -it "$POD" -- bash -lc '
> source /opt/ros/$ROS_DISTRO/setup.bash
> export PYTHONPATH="/app:$PYTHONPATH"
> hypercorn app:app -b 0.0.0.0:5500 --workers 1 --log-level debug --access-log -
> '
{"ts": "2025-10-04T17:15:33.748Z", "level": "info", "svc": "trix-ui", "host": "ui-7469d449dc-rth87", "pid": 154, "thread": "Thread-5 (_ws_broadcast_loop)", "subsystem": "WS", "req_id": null, "msg": "[WS] Broadcast loop iniciado", "name": "app", "levelname": "INFO", "levelno": 20, "pathname": "/app/app.py", "filename": "app.py", "module": "app", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 178, "funcName": "_ws_broadcast_loop", "created": 1759598133.74817, "msecs": 748.0, "relativeCreated": 566.4288997650146, "threadName": "Thread-5 (_ws_broadcast_loop)", "processName": "SpawnProcess-1", "process": 154}
{"ts": "2025-10-04T17:15:33.748Z", "level": "info", "svc": "trix-ui", "host": "ui-7469d449dc-rth87", "pid": 154, "thread": "Thread-6 (_ws_udp_snapshot_loop)", "subsystem": "WS", "req_id": null, "msg": "[WS] UDP snapshot mirror loop iniciado (2.0s)", "name": "app", "levelname": "INFO", "levelno": 20, "pathname": "/app/app.py", "filename": "app.py", "module": "app", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 190, "funcName": "_ws_udp_snapshot_loop", "created": 1759598133.7486968, "msecs": 748.0, "relativeCreated": 566.9558048248291, "threadName": "Thread-6 (_ws_udp_snapshot_loop)", "processName": "SpawnProcess-1", "process": 154}



kubectl exec -it "$POD" -- bash -lc '
> source /opt/ros/$ROS_DISTRO/setup.bash
> export PYTHONPATH="/app:$PYTHONPATH"
 hypercorn app:app -b 0.0.0.0:5500 --workers 1 --log-level debug --access-log -
 '

---------------------





# IMPORTANTE: no pongas CMD que haga "source" aqu√≠; usa /ros_entrypoint.sh desde docker-compose.

#Architecture and Design

  #  Guidelines - How to architect ROS-based systems.
  #  yEd - A powerful desktop application that can be used to quickly and effectively generate high-quality diagrams.
  #  yed_py - Generates graphML that can be opened in yEd.
  #  Plantuml - Web application to generate UML diagrams on-the-fly in your live documentation.
  #  rqt_graph - Provides a GUI plugin for visualizing the ROS computation graph.
  #  rqt_launchtree - An RQT plugin for hierarchical launchfile configuration introspection.
  #  cpp-dependencies - Tool to check C++ #include dependencies (dependency graphs created in .dot format).
  #  pydeps - Python Module Dependency graphs.
  #  aztarna - A footprinting tool for robots.
  #  draw.io - A free online diagram software for making flowcharts, process diagrams, org charts, UML, ER and network diagrams.
  #  vscode-drawio - This extension integrates Draw.io into VS Code.
  #  Architecture_Decision_Record - A document that captures an important architectural decision made along with its context and consequences.
#   https://github.com/araffin/robotics-rl-srl


# Documentation and Presentation

  #  Typora - A Minimalist Markdown Editor.
  #  Markor - A Simple Markdown Editor for your Android Device.
  #  Pandoc - Universal markup converter.
  #  Yaspeller - Command line tool for spell checking.
  #  ReadtheDocs - Build your local ReadtheDocs Server.
  #  Doxygen - Doxygen is the de facto standard tool for generating documentation from annotated C++ sources.
  #  Sphinx - A tool that makes it easy to create intelligent and beautiful documentation for Python projects.
  #  Word-to-Markdown - A ruby gem to liberate content from Microsoft Word document.
  #  paperless - Index and archive all of your scanned paper documents.
  #  carbon - Share beautiful images of your source code.
  #  undraw - Free Professional business SVGs easy to customize.
  #  asciinema - Lets you easily record terminal sessions and replay them in a terminal as well as in a web browser.
  #  inkscape - Inkscape is a professional vector graphics editor for Linux, Windows and macOS.
  #  Reveal-Hugo - A Hugo theme for Reveal.js that makes authoring and customization a breeze. With it, you can turn any properly-formatted Hugo content into a HTML presentation.
  #  Hugo-Webslides - This is a Hugo template to create WebSlides presentation using markdown.
  #  jupyter2slides - Cloud Native Presentation Slides with Jupyter Notebook + Reveal.js.
  #  patat - Terminal-based presentations using Pandoc.
  #  github-changelog-generator - Automatically generate change log from your tags, issues, labels and pull requests on GitHub.
  #  GitLab-Release-Note-Generator - A Gitlab release note generator that generates release note on latest tag.
  #  OCRmyPDF - Adds an OCR text layer to scanned PDF files, allowing them to be searched.
  #  papermill - A tool for parameterizing, executing, and analyzing Jupyter Notebooks.
  #  docsy - An example documentation site using the Docsy Hugo theme.
  #  actions-hugo - Deploy website based on Hugo to GitHub Pages.
  #  overleaf - An open-source online real-time collaborative LaTeX editor.
  #  landslide - Generate HTML5 slideshows from markdown, ReST, or textile.
  #  libreoffice-impress-templates - Freely-licensed LibreOffice Impress templates.
  #  opensourcedesign - Community and Resources for Free Design and Logo Creation.
  #  olive - A free non-linear video editor aiming to provide a fully-featured alternative to high-end professional video editing software.
  #  buku - Browser-independent bookmark manager.
  #  swiftlatex - A WYSIWYG Browser-based LaTeX Editor.
  #  ReLaXed - Allows complex PDF layouts to be defined with CSS and JavaScript, while writing the content in a friendly, minimal syntax close to Markdown or LaTeX.
  #  foam - Foam is a personal knowledge management and sharing system inspired by Roam Research, built on Visual Studio Code and GitHub.
  #  CodiMD - Open Source Online Real-time collaborate on team documentation in markdown.
  #  jupyter-book - Build interactive, publication-quality documents from Jupyter Notebooks.
  #  InvoiceNet - Deep neural network to extract intelligent information from invoice documents.
  #  tesseract - Open Source OCR Engine.
  #  mkdocs - A fast, simple and downright gorgeous static site generator that's geared towards building project documentation.
  #  PlotNeuralNet - Latex code for drawing neural networks for reports and presentation.
  #  Excalidraw - Virtual whiteboard for sketching hand-drawn like diagrams.
  #  SVGrepo - Download free SVG Vectors for commercial use.
  #  gollum - A simple, Git-powered wiki with a sweet API and local frontend.
  #  GanttLab - The easy to use, fully functional Gantt chart for GitLab and GitHub.
  #  Zotero - A free, easy-to-use tool to help you collect, organize, cite, and share your research sources.

  # Communication and Coordination

  #  Agile Development - Manifesto for Agile Software Development.
  #  Gitflow - Makes parallel development very easy, by isolating new development from finished work.
  #  DeepL - An online translator that outperforms Google, Microsoft and Facebook.
  #  Taiga - Agile Projectmanagment Tool.
  #  Kanboard - Minimalistic Kanban Board.
  #  kanban - Free, open source, self-hosted, Kanban board for GitLab issues.
  #  Gitlab - Simple Selfhosted Gitlab Server with Docker.
  #  Gogs - Build a simple, stable and extensible self-hosted Git service that can be setup in the most painless way.
  #  Wekan - Meteor based Kanban Board.
  #  JIRA API - Python Library for REST API of Jira.
  #  Taiga API - Python Library for REST API of Taiga.
  #  Chronos-Timetracker - Desktop client for JIRA. Track time, upload worklogs without a hassle.
  #  Grge - Grge is a daemon and command line utility augmenting GitLab.
  #  gitlab-triage - Gitlab's issues and merge requests triage, automated.
  #  Helpy - A modern, open source helpdesk customer support application.
  #  ONLYOFFICE - A free open source collaborative system developed to manage documents, projects, customer relationship and email correspondence, all in one place.
  #  discourse - A platform for community discussion. Free, open, simple.
  #  Gerrit - A code review and project management tool for Git based projects.
  #  jitsi-meet - Secure, Simple and Scalable Video Conferences that you use as a standalone app or embed in your web application.
  #  mattermost - An open source, private cloud, Slack-alternative.
  #  openproject - The leading open source project management software.
  #  leantime - Leantime is a lean project management system for innovators.
  #  gitter - Gitter is a chat and networking platform that helps to manage, grow and connect communities through messaging, content and discovery.

   # Debugging and Tracing

    # heaptrack - Traces all memory allocations and annotates these events with stack traces.
    # ros2_tracing - Tracing tools for ROS 2.
     #Linuxperf - Various Linux performance material.
     # lptrace - It lets you see in real-time what functions a Python program is running.
     # pyre-check - Performant type-checking for python.
    # FlameGraph - Visualize profiled code.
    # gpuvis - GPU Trace Visualizer.
    # sanitizer - AddressSanitizer, ThreadSanitizer, MemorySanitizer.
    # cppinsights - C++ Insights - See your source code with the eyes of a compiler.
    # inspect - The inspect module provides functions for learning about live objects, including modules, classes, instances, functions, and methods.
    # Roslaunch Nodes in Valgrind or GDB - When debugging roscpp nodes that you are launching with roslaunch, you may wish to launch the node in a debugging program like gdb or valgrind instead.
    # pyperformance - Python Performance Benchmark Suite.
    # qira - QIRA is a competitor to strace and gdb.
    # gdb-frontend - GDBFrontend is an easy, flexible and extensionable gui debugger.
    # lttng - An open source software toolkit which you can use to simultaneously trace the Linux kernel, user applications, and user libraries.
    # ros2-performance - Allows to easily create arbitrary ROS2 systems and then measures their performance.
    # bcc - Tools for BPF-based Linux IO analysis, networking, monitoring, and more.
    # tracy - A real time, nanosecond resolution, remote telemetry frame profiler for games and other applications.
    # bpftrace - High-level tracing language for Linux eBPF.
    # pudb - Full-screen console debugger for Python.
    # backward-cpp - A beautiful stack trace pretty printer for C++.
    # gdb-dashboard - GDB dashboard is a standalone .gdbinit file written using the Python API that enables a modular interface showing relevant information about the program being debugged.
    # hotspot - The Linux perf GUI for performance analysis.
     
    # memory_profiler - A python module for monitoring memory consumption of a process as well as line-by-line analysis of memory consumption for python programs.
    # ros1_fuzzer - This fuzzer aims to help developers and researchers to find bugs and vulnerabilities in ROS nodes by performing fuzz tests over topics that the target nodes process.
    # vscode-debug-visualizer - An extension for VS Code that visualizes data during debugging.
    # action-tmate - Debug your GitHub Actions via SSH by using tmate to get access to the runner system itself.
    # libstatistics_collector - ROS 2 library providing classes to collect measurements and calculate statistics across them.
    # system_metrics_collector - Lightweight, real-time system metrics collector for ROS2 systems.

 #Version Control

   #  git-fuzzy - A CLI interface to git that relies heavily on fzf.
    # meld - Meld is a visual diff and merge tool that helps you compare files, directories, and version controlled projects.
    # tig - Text-mode interface for git.
    # gitg - A graphical user interface for git.
    # git-cola - The highly caffeinated Git GUI.
    # python-gitlab - A Python package providing access to the GitLab server API.
    # bfg-repo-cleaner - Removes large or troublesome blobs like git-filter-branch does, but faster.
    # nbdime - Tools for diffing and merging of Jupyter notebooks.
    # semantic-release - Fully automated version management and package publishing.
    # go-semrel-gitab - Automate version management for Gitlab.
    # Git-repo - Git-Repo helps manage many Git repositories, does the uploads to revision control systems, and automates parts of the development workflow.
    # dive - A tool for exploring each layer in a docker image.
    # dvc - Management and versioning of datasets and machine learning models.
    # learnGitBranching - A git repository visualizer, sandbox, and a series of educational tutorials and challenges.
    # gitfs - You can mount a remote repository's branch locally, and any subsequent changes made to the files will be automatically committed to the remote.
    # git-secret - Encrypts files with permitted users' public keys, allowing users you trust to access encrypted data using pgp and their secret keys.
    # git-sweep - A command-line tool that helps you clean up Git branches that have been merged into master.
    # lazygit - A simple terminal UI for git commands, written in Go with the gocui library.
    #glab - An open-source GitLab command line tool.

 #Simulation

   #  AI2-THOR - Python framework with a Unity backend providing interaction, navigation, and manipulation support for household based robotic agents, consisting of 200+ of custom scenes, 1500+ custom annotated objects, and 200+ actions.
    # Drake - Drake aims to simulate even very complex dynamics of robots.
    # Webots - Webots is an open source robot simulator compatible (among others) with ROS and ROS2.
    # lgsv - LG Electronics America R&D Center has developed an HDRP Unity-based multi-robot simulator for autonomous vehicle developers.
    # carla - Open-source simulator for autonomous driving research.
    # awesome-CARLA - A curated list of awesome CARLA tutorials, blogs, and related projects.
    # ros-bridge - ROS bridge for CARLA Simulator.
    # scenario_runner - Traffic scenario definition and execution engine.
    # deepdive - End-to-end simulation for self-driving cars.
    # uuv_simulator - Gazebo/ROS packages for underwater robotics simulation.
    # AirSim - Open source simulator for autonomous vehicles built on Unreal Engine.
    # self-driving-car-sim - A self-driving car simulator built with Unity.
    #ROSIntegration - Unreal Engine Plugin to enable ROS Support.
    # gym-gazebo - An OpenAI gym extension for using Gazebo known as gym-gazebo.
    # gym-pybullet-drones - PyBullet-based Gym environments for single and multi-agent reinforcement learning of quadcopter control.
    # safe-control-gym - PyBullet-based CartPole and Quadrotor environments‚Äîwith CasADi symbolic dynamics and constraints‚Äîfor safe and robust learning-based control.
    # highway-env - A collection of environments for autonomous driving and tactical decision-making tasks.
    # VREP Interface - ROS Bridge for the VREP simulator.
    # car_demo - This is a simulation of a Prius in gazebo 9 with sensor data being published using ROS kinetic.
    # sumo - Eclipse SUMO is an open source, highly portable, microscopic and continuous road traffic simulation package designed to handle large road networks.
    # open-simulation-interface - A generic interface for the environmental perception of automated driving functions in virtual scenarios.
    # ESIM - An Open Event Camera Simulator.
    # Menge - Crowd Simulation Framework.
    # pedsim_ros - Pedestrian simulator powered by the social force model for Gazebo.
    # opencrg - Open file formats and open source tools for the detailed description, creation and evaluation of road surfaces.
    # esmini - A basic OpenSCENARIO player.
    # OpenSceneGraph - An open source high performance 3D graphics toolkit, used by application developers in fields such as visual simulation, games, virtual reality, scientific visualization and modelling.
    # morse - An academic robotic simulator, based on the Blender Game Engine and the Bullet Physics engine.
   #  ROSIntegrationVision - Support for ROS-enabled RGBD data acquisition in Unreal Engine Projects.
   #  fetch_gazebo - Contains the Gazebo simulation for Fetch Robotics Fetch and Freight Research Edition Robots.
   #  rotors_simulator - Provides some multirotor models.
   # flow - A computational framework for deep RL and control experiments for traffic microsimulation.
  #  gnss-ins-sim - GNSS + inertial navigation, sensor fusion simulator. Motion trajectory generator, sensor models, and navigation.
  #  Ignition Robotics - Test control strategies in safety, and take advantage of simulation in continuous integration tests.
  #  simulation assets for the SubT - This collection contains simulation assets for the SubT Challenge Virtual Competition in Gazebo.
  #  gazebo_ros_motors - Contains currently two motor plugins for Gazebo, one with an ideal speed controller and one without a controller that models a DC motor.
  #  map2gazebo - ROS package for creating Gazebo environments from 2D maps.
  #  sim_vehicle_dynamics - Vehicle Dynamics Simulation Software of TUM Roborace Team.
  #  gym-carla - An OpenAI gym wrapper for CARLA simulator.
  #  simbody - High-performance C++ multibody dynamics/physics library for simulating articulated biomechanical and mechanical systems like vehicles, robots, and the human skeleton.
  #  gazebo_models - This repository holds the Gazebo model database.
   #  pylot - Autonomous driving platform running on the CARLA simulator.
    # flightmare - Flightmare is composed of two main components: a configurable rendering engine built on Unity and a flexible physics engine for dynamics simulation.
    # champ - ROS Packages for CHAMP Quadruped Controller.
    # rex-gym - OpenAI Gym environments for an open-source quadruped robot (SpotMicro).
    # Trick - Developed at the NASA Johnson Space Center, is a powerful simulation development framework that enables users to build applications for all phases of space vehicle development.
   #  usv_sim_lsa - Unmanned Surface Vehicle simulation on Gazebo with water current and winds.
   #  42 - Simulation for spacecraft attitude control system analysis and design.
   #  Complete_Street_Rule - A scenario oriented design tool intended to enable users to quickly create procedurally generated multimodal streets in ArcGIS CityEngine.
   #  AutoCore simulation - Provides test environment for Autoware and still during early development, contents below may changed during updates.
   #  fields-ignition - Generate random crop fields for Ignition Gazebo.
   #  Unity-Robotics-Hub - Central repository for tools, tutorials, resources, and documentation for robotic simulation in Unity.
   #  BlueSky - The goal of BlueSky is to provide everybody who wants to visualize, analyze or simulate air traffic with a tool to do so without any restrictions, licenses or limitations.
   #  Cloe - Empowers developers of automated-driving software components by providing a unified interface to closed-loop simulation.
   #  Dynamic_logistics_Warehouse - Gazebo simulation of dynamics environment in warehouses.
 #    OpenCDA - A generalized framework for prototyping full-stack cooperative driving automation applications under CARLA+SUMO.

 #Electronics and Mechanics

   #  HRIM - An information model for robot hardware.
   #  URDF - Repository for Unified Robot Description Format (URDF) parsing code.
   #  phobos - An add-on for Blender allowing to create URDF, SDF and SMURF robot models in a WYSIWYG environment.
   #  urdf-viz - Visualize URDF/XACRO file, URDF Viewer works on Windows/macOS/Linux.
   #  solidworks_urdf_exporter - SolidWorks to URDF Exporter.
   #  FreeCAD - Your own 3D parametric modeler.
   #  kicad - A Cross Platform and Open Source Electronics Design Automation Suite.
   #  PcbDraw - Convert your KiCAD board into a nice looking 2D drawing suitable for pinout diagrams.
   #  kicad-3rd-party-tools - Tools made by others to augment the KiCad PCB EDA suite.
   #  PandaPower - An easy to use open source tool for power system modeling, analysis and optimization with a high degree of automation.
   #  LibrePCB - A powerful, innovative and intuitive EDA tool for everyone.
   #  openscad - A software for creating solid 3D CAD models.
  #   ngspice - A open source spice simulator for electric and electronic circuits.
  #   GNSS-SDR - GNSS-SDR provides interfaces for a wide range of radio frequency front-ends and raw sample file formats, generates processing outputs in standard formats.
  #   riscv - The Free and Open RISC Instruction Set Architecture.
  #   urdfpy - A simple and easy-to-use library for loading, manipulating, saving, and visualizing URDF files.
  #   FMPy - Simulate Functional Mockup Units (FMUs) in Python.
  #   FMIKit-Simulink - Import and export Functional Mock-up Units with Simulink.
 #    oemof-solph - A modular open source framework to model energy supply systems.
  #   NASA-3D-Resources - Here you'll find a growing collection of 3D models, textures, and images from inside NASA.
  #   SUAVE - An Aircraft Design Toolbox.
  #   opem - The Open-Source PEMFC Simulation Tool (OPEM) is a modeling tool for evaluating the performance of proton exchange membrane fuel cells.
  #   pvlib-python - A community supported tool that provides a set of functions and classes for simulating the performance of photovoltaic energy systems.
  #   WireViz - A tool for easily documenting cables, wiring harnesses and connector pinouts.
  #   Horizon - EDA is an Electronic Design Automation package supporting an integrated end-to-end workflow for printed circuit board design including parts management and schematic entry.
  #   tigl - The TiGL Geometry Library can be used for the computation and processing of aircraft geometries stored inside CPACS files.
  #   foxBMS - A free, open and flexible development environment to design battery management systems.
  #   cadCAD - A Python package that assists in the processes of designing, testing and validating complex systems through simulation, with support for Monte Carlo methods, A/B testing and parameter sweeping.
  #   OpenMDAO - An open-source framework for efficient multidisciplinary optimization.
  #   ODrive - The aim is to make it possible to use inexpensive brushless motors in high performance robotics projects.
  #   OpenTirePython - An open-source mathematical tire modelling library.
  #   Inkscape Ray Optics - An extension for Inkscape that makes it easier to draw optical diagrams.
  #   OpenAeroStruct - A lightweight tool that performs aerostructural optimization using OpenMDAO.

#  Sensor Processing
# Calibration and Transformation

 #   tf2 - Transform library, which lets the user keep track of multiple coordinate frames over time.
  #  TriP - A Inverse Kinematics library for serial robots, parallel robots and hybrids of both.
  #  lidar_align - A simple method for finding the extrinsic calibration between a 3D lidar and a 6-dof pose sensor.
  #  kalibr - The Kalibr visual-inertial calibration toolbox.
  #  Calibnet - Self-Supervised Extrinsic Calibration using 3D Spatial Transformer Networks.
  #  lidar_camera_calibration - ROS package to find a rigid-body transformation between a LiDAR and a camera.
  #  ILCC - Reflectance Intensity Assisted Automatic and Accurate Extrinsic Calibration of 3D LiDAR.
  #  easy_handeye - Simple, straighforward ROS library for hand-eye calibration.
  #  imu_utils - A ROS package tool to analyze the IMU performance.
  #  kalibr_allan - IMU Allan standard deviation charts for use with Kalibr and inertial kalman filters.
  #  pyquaternion - A full-featured Python module for representing and using quaternions.
  #  robot_calibration - This package offers calibration of a number of parameters of a robot, such as: 3D Camera intrinsics, extrinsics Joint angle offsets and robot frame offsets.
  #  multi_sensor_calibration - Contains a calibration tool to calibrate a sensor setup consisting of lidars, radars and cameras.
  #  LiDARTag - A Real-Time Fiducial Tag using Point Clouds Lidar Data.
  #  multicam_calibration - Extrinsic and intrinsic calbration of cameras.
  #  ikpy - An Inverse Kinematics library aiming performance and modularity.
  #  livox_camera_lidar_calibration - Calibrate the extrinsic parameters between Livox LiDAR and camera.
  #  lidar_camera_calibration - Camera LiDAR Calibration using ROS, OpenCV, and PCL.
  #  e2calib - Contains code that implements video reconstruction from event data for calibration.

#Perception Pipeline

 #   SARosPerceptionKitti - ROS package for the Perception (Sensor Processing, Detection, Tracking and Evaluation) of the KITTI Vision Benchmark Suite.
  #  multiple-object-tracking-lidar - C++ implementation to Detect, track and classify multiple objects using LIDAR scans or point cloud.
  #  cadrl_ros - ROS package for dynamic obstacle avoidance for ground robots trained with deep RL.
  #  AugmentedAutoencoder - RGB-based pipeline for object detection and 6D pose estimation.
  #  jsk_recognition - A stack for the perception packages which are used in JSK lab.
  #  GibsonEnv - Gibson Environments: Real-World Perception for Embodied Agents.
  #  morefusion - Multi-object Reasoning for 6D Pose Estimation from Volumetric Fusion.
  #  se(3)-TrackNet - A package for 6D pose tracking of dynamic objects when object's CAD model is available.

# Machine Learning
# DLIB - A toolkit for making real world machine learning and data analysis applications in C++.
# fastai - The fastai library simplifies training fast and accurate neural nets using modern best practices.
# tpot - A Python Automated Machine Learning tool that optimizes machine learning pipelines using genetic programming.
# deap - Distributed Evolutionary Algorithms in Python.
# gym - A toolkit for developing and comparing reinforcement learning algorithms.
# tensorflow_ros_cpp - A ROS package that allows to do Tensorflow inference in C++ without the need to compile TF yourself.
# Tensorflow Federated - TensorFlow Federated (TFF) is an open-source framework for machine learning and other computations on decentralized data.
# finn - Fast, Scalable Quantized Neural Network Inference on FPGAs.
# neuropod - Neuropod is a library that provides a uniform interface to run deep learning models from multiple frameworks in C++ and Python.
# leela-zero - This is a fairly faithful reimplementation of the system described in the Alpha Go Zero paper "Mastering the Game of Go without Human Knowledge".
# Trax - A library for deep learning that focuses on sequence models and reinforcement learning.
# mlflow - A platform to streamline machine learning development, including tracking experiments #, packaging code into reproducible runs, and sharing and deploying models.
 #Netron - Visualizer for neural network, deep learning and machine learning models.
 #MNN - A blazing fast, lightweight deep learning framework, battle-tested by business-critical use cases in Alibaba.
 #Tensorforce - An open-source deep reinforcement learning framework, with an emphasis on modularized flexible library design and straightforward usability for applications in research and practice.
 #Dopamine - A res












